#!/bin/bash -efu
# SPDX-License-Identifier: GPL-2.0

PROG="${0##*/}"
PROGCMD="${PROG#git-}"

[ -t 1 ] &&
	color=always ||
	color=none

message()
{
	printf >&2 '%s: %s\n' "$PROG" "$*"
}

fatal()
{
	message "$*"
	exit 1
}

quote_regexp()
{
	local out="$*"
	if [ -z "${out##*[\[\].*&^\$\\\\/]*}" ]; then
		out="$(printf %s "$out" |
				sed -e 's/[].*&^$[\/]/\\&/g')" ||
			return 1
	fi
	printf '%s' "$out"
}

startup_working_directory=''
chdir_to_toplevel()
{
	local cdup
	cdup="$(git rev-parse --show-cdup)"
	if [ -z "$cdup" ]; then
		startup_working_directory=''
	else
		startup_working_directory="$PWD"
		cd "$cdup" ||
			fatal "Cannot chdir to $cdup, the toplevel of the working tree"
	fi
}

workdir=
cleanup_handler()
{
	trap - EXIT
	[ -z "$workdir" ] ||
		rm -rf -- "$workdir" ||:
	exit "$1"
}

exit_handler()   { cleanup_handler $?; }
signal_handler() { cleanup_handler  1; }

readonly P_FULL=0 P_NAME=1 P_TYPE=2 P_VERS=3

# in: refs/heads/patchset/sysctl-ipc/v1.0
# out: "patchset/sysctl-ipc/v1.0" "sysctl-ipc" "v" "1.0"
parse_patchset()
{
	if [[ "$1" =~ ^(refs/)?(heads/)?(patchset/([^/]+)(/([av])([0-9]+.[0-9]+))?) ]]; then
		patchset=("${BASH_REMATCH[3]}" "${BASH_REMATCH[4]}" "${BASH_REMATCH[6]-}" "${BASH_REMATCH[7]-}")
	elif [[ "$1" =~ ^(([^/]+)(/([av])([0-9]+.[0-9]+))?) ]]; then
		patchset=("patchset/${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}" "${BASH_REMATCH[4]-}" "${BASH_REMATCH[5]-}")
	else
		fatal "branch is not a patchset: $1"
	fi

	local refspec="refs/heads/patchset/${patchset[$P_NAME]}/${patchset[$P_TYPE]-[av]}${patchset[$P_VERS]-[0-9]*}"

	[ -n "$(git for-each-ref --format=1 "$refspec")" ] ||
		fatal "nothing matches the specified refspec: $1"
}

current_patchset()
{
	local ref
	ref="$(git branch --show-current --format='%(refname)')" ||
		fatal "unable to obtain current branch name"
	parse_patchset "$ref"
}

builtin_cat()
{
	local s eof=
	while [ -z "$eof" ]; do
		read -r -N 1 s || eof=1
		printf '%s' "$s"
	done
}

get_pager()
{
	local __get_pager
	__get_pager="$(git config --get patchset.pager)" ||
		__get_pager="$(git config --get core.pager)" ||
		__get_pager="less"
	eval "$1=\"\$__get_pager\""
}

basecommit_for()
{
	local merge remote
	if ! merge="$(git config "branch.$1.merge")"; then
		message "not found upstream for branch: $1"
		message "Use \`git branch -u <upstream> $1\` to set upstream for branch."
		return 1
	fi

	if ! remote="$(git config "branch.$1.remote")"; then
		message "unable to find \"branch.$1.remote\"."
		return 1
	fi

	case "$remote" in
		'.')
			;;
		*)
			merge="${merge#refs/}"
			merge="${merge#heads/}"
			merge="refs/remotes/$remote/$merge"
			;;
	esac

	git rev-parse --short "$merge" || {
		message "unable to resolve reference: $merge"
		return 1
	}
}

help_create()
{
	case "$1" in
		usage) printf 'create <newname> [options]\n'
			;;
		descr) builtin_cat <<-EOF
			Creates branch for a new patchset. The new branch will be
			created with v1 version. the version and cover can be
			overwritten if commits are imported from mbox file.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --no-edit-cover             do not offer to edit cover.
			  -S, --start-point=COMMIT    specifying a COMMIT allows you to create a branch
			                              based on some other point in history than where
			                              HEAD currently points.
			  -m, --use-local-mbox=FILE   process FILE mbox to import patchset.
			  -h, --help                  show this text and exit.
			EOF
			;;
	esac
}

cmd_create()
{
	local args branchname='' startpoint='' mbox='' no_edit_cover=''

	args=()
	while [ "$#" -gt 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help create
				return
				;;
			--no-edit-cover)
				no_edit_cover=1
				;;
			-S|--start-point)
				[ "$#" -gt 1 ] ||
					fatal "argument required for $1 option"
				startpoint="$2"
				shift
				;;
			--start-point=*)
				startpoint="${1#--start-point=}"
				;;
			-m|--use-local-mbox)
				[ "$#" -gt 1 ] ||
					fatal "argument required for $1 option"
				mbox="$2"
				shift
				;;
			--use-local-mbox=*)
				mbox="${1#--use-local-mbox=}"
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}"

	[ "$#" != 0 ] ||
		fatal "patchset name required"

	branchname="$1"
	shift

	if [ "$#" != 0 ]; then
		[ -z "$startpoint" ] ||
			fatal "start-point already specified via options"
		startpoint="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	branchname="${branchname#/}"
	branchname="${branchname%/}"

	[ -n "$branchname" ] ||
		fatal "empty branch name is not allowed"

	local newver="v1.0"
	local cover="*** SUBJECT HERE ***

*** PATCHSET DESCRIPTION HERE ***

--
"
	if [ -s "$mbox" ]; then
		if ! type -p b4 >/dev/null; then
			errmsg="the b4 utility is required to import mbox"
			break
		fi

		workdir="$(git rev-parse --absolute-git-dir)/$PROG.temp"

		if ! mkdir -- "$workdir"; then
			workdir=''
			exit 1
		fi

		b4 -q am -o "$workdir" -m "$mbox" ||
			fatal "unable to create an mbox file that is ready to git-am"

		local fn

		fn="$(set +f && echo "$workdir"/*.mbx)"
		[ -f "$fn" ] ||
			fatal "unable to find created mbox"

		mbox="$fn"

		if [[ "${fn##*/}" =~ ^(v[0-9]+)_ ]]; then
			newver="${BASH_REMATCH[1]}.0"
		fi

		fn="$(set +f && echo "$workdir"/*.cover)"
		if [ -s "$fn" ]; then
			git mailinfo "$fn.msg" /dev/null < "$fn" > "$fn.info"
			cover="$(sed -n -e 's/^Subject:[[:space:]]\+//p' "$fn.info")

$(<"$fn.msg")
"
		fi
	fi

	git switch \
		--create "patchset/$branchname/$newver" \
		--track ${startpoint:+"$startpoint"} ||
		fatal "unable to create new branch: patchset/$branchname/$newver"

	[ -z "$mbox" ] ||
		git am -- "$mbox"

	git config "branch.patchset/$branchname/$newver.description" "$cover" ||
		fatal "unable to write empty description for patchset/$branchname/$newver"

	[ -n "$mbox" ] || [ -n "$no_edit_cover" ] ||
		git branch --edit-description "patchset/$branchname/$newver" ||
			fatal "unable to change description"

	message "new patchset created: patchset/$branchname/$newver"
}

describe_patchset()
{
	local branchname basecommit subject_prefix ver

	branchname="$1"; shift
	basecommit="$(basecommit_for "$branchname")" ||
		return 1

	subject_prefix="$(git config --get branch.$branchname.subject-prefix)" ||:
	subject_prefix="${subject_prefix:+$subject_prefix }PATCH"

	ver="${branchname##*/[av]}"
	ver="${ver%%.*}"

	show_field_list()
	{
		local arr i n="$1"

		readarray -t arr <<< $(
			git config --get-all patchset.$2 ||:;
			git config --get-all branch.$branchname.$2 ||:;
		)

		for i in "${!arr[@]}"; do
			[ -n "${arr[$i]}" ] ||
				continue
			printf "%-${#1}s %s" "$n" "${arr[$i]}"
			[ "$i" = "$(( ${#arr[@]} - 1 ))" ] ||
				printf ','
			printf '\n'
			n=
		done
	}

	printf 'From %s %s\n' \
		"$(git config --get user.email)" \
		"$(LANG=C date -u)" ||:
	show_field_list To: to
	show_field_list Cc: cc
	printf 'Subject: [%s v%s 0/%s] %s\n\n' \
		"$subject_prefix" \
		"$ver" \
		"$(git rev-list --count "$basecommit..$branchname")" \
		"$(git config "branch.$branchname.description")"
	git rev-list --date-order --reverse --abbrev-commit --format=oneline \
		"$basecommit..$branchname"
}

fetch_config_section()
{
	local branchname infile outfile inkeys outkeys inname outname

	branchname="$1"; shift
	infile="$1"; shift
	outfile="$1"; shift

	list_config_keys()
	{
		eval "$1=()"
		readarray -t "$1" <<< $(
			for n in "patchset." "branch.$branchname."; do
				printf '%s\n' "${n}to" "${n}cc"
				git config -f "$2" --name-only --get-regexp "^$(quote_regexp "$n")" |
					grep -v -e '\.\(to\|cc\|description\)$' |
					sort -u
			done)
	}

	list_config_keys inkeys "$infile"
	list_config_keys outkeys "$outfile"

	for inname in "${inkeys[@]}"; do
		git config -f "$outfile" --unset-all "$inname" ||:
		git config -f "$infile" --get-all "$inname" 2>/dev/null | sort -u |
		while read -r value; do
			git config -f "$outfile" --add "$inname" "$value"
		done
	done

	for outname in "${outkeys[@]}"; do
		for inname in "${inkeys[@]}"; do
			[ "$inname" != "$outname" ] || continue 2
		done
		git config -f "$outfile" --unset-all "$outname"
	done
}

help_config()
{
	case "$1" in
		usage) builtin_cat <<-EOF
			config [-e|--edit] [<patchset>]
			config [--global] [--to=<email>] [--cc=<email>] [<patchset>]
			EOF
			;;
		descr) builtin_cat <<-EOF
			Changes options of the patchset. You can always change or delete To
			and Cc fields using the \`git config -e'.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --global        add <email> globally for all patchsets.
			  --to=<email>    add a To: header to the email headers.
			  --cc=<email>    add a Cc: header to the email headers.
			  -e, --edit      open editor to change options.
			  -h, --help      show this text and exit.
			EOF
			;;
	esac
}

cmd_config()
{
	local mode=edit
	local to cc args patchset cfg_prefix=''

	to=(); cc=(); args=();

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help config
				return
				;;
			-e|--edit)
				mode=edit
				;;
			--global)
				cfg_prefix="patchset"
				;;
			--to=*)
				to+=("${1#--to=}")
				mode=tocc
				;;
			--cc=*)
				cc+=("${1#--cc=}")
				mode=tocc
				;;
			--)
				shift
				break
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}" "$@"

	if [ "$#" -gt 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	[ "$#" -eq 0 ] ||
		fatal "too many arguments"

	[ -n "${patchset[$P_NAME]}" ] && [ -n "${patchset[$P_VERS]}" ] ||
		fatal "unable to parse patchset"

	if [ -n "$cfg_prefix" ]; then
		[ "$mode" != 'edit' ] ||
			fatal "options --edit and --global are mutually exclusive"
	fi

	if [ "${#to[@]}" != 0 ] || [ "${#cc[@]}" != 0 ]; then
		local cc_nr=0 to_nr=0 arr

		arr=()
		readarray -t arr <<< $(
			git config --get-all patchset.to ||:;
			git config --get-all patchset.cc ||:;
		)
		if [ -z "$cfg_prefix" ]; then
			readarray -O "${#arr[@]}" -t arr <<< $(
				git config --get-all branch.${patchset[$P_FULL]}.to ||:;
				git config --get-all branch.${patchset[$P_FULL]}.cc ||:;
			)
			cfg_prefix="branch.${patchset[$P_FULL]}"
		fi

		add_recipient()
		{
			local field counter a n
			field="$1"; shift
			counter="$1"; shift
			for a in "$@"; do
				for n in "${arr[@]}" ; do
					if [ "$n" = "$a" ]; then
						message "address already exists: $n"
						continue 2
					fi
				done
				git config --add "$cfg_prefix.$field" "$a"
				eval "$counter=\$((\$$counter + 1))"
			done
		}

		add_recipient to to_nr "${to[@]}"
		add_recipient cc cc_nr "${cc[@]}"
	fi

	case "$mode" in
		edit)
			local git_dir rc=0

			git_dir="$(git rev-parse --absolute-git-dir)"

			builtin_cat > "$git_dir/config.patchset.ini" <<EOF
[patchset]

[branch "${patchset[$P_FULL]}"]
#
# Available fields:
#
# - patchset.to, branch.*.to, patchset.cc, branch.*.cc
#
# Fields define the recipients for this patchset. One recipient per line. The
# field can be specified multiple times.  If you specify fields in the patchset
# section, they will be substituted for any other patchsets.
#
# - branch.*.subject-prefix
#
# Add value to the subject of each patch.
#
EOF
			(
				fetch_config_section "${patchset[$P_FULL]}" \
					"$git_dir/config" \
					"$git_dir/config.patchset.ini"

				git config \
					--file "$git_dir/config.patchset.ini" \
					--edit

				fetch_config_section "${patchset[$P_FULL]}" \
					"$git_dir/config.patchset.ini" \
					"$git_dir/config"
			) || rc=$?

			rm -f -- "$git_dir/config.patchset.ini"

			[ "$rc" = 0 ] ||
				return $rc
			;;
		tocc)
			[ "${#to[@]}" = 0 ] || message "added $to_nr new addresses to \`To' list"
			[ "${#cc[@]}" = 0 ] || message "added $cc_nr new addresses to \`Cc' list"
			;;
	esac

}

help_list()
{
	case "$1" in
		usage) printf 'list [--all|--latest|--versions] [--archive]\n'
			;;
		descr) builtin_cat <<-EOF
			Shows a list of known patchsets. The current patchset will
			be marked with an asterisk. The list also shows the base and
			last commits as well as the number of commits.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --all        show all versions of all patchsets.
			  --latest     show only latest versions of patchsets.
			  --versions   show all versions of current patchset.
			  --archive    show archived patchsets.
			  -h, --help   show this text and exit.
			EOF
			;;
	esac
}

cmd_list()
{
	local mode='' ver=v show_current='' patchset

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help list
				return
				;;
			--all|--latest|--versions)
				mode="${1#--}"
				;;
			--archive)
				mode="${mode:-latest}"
				ver=a
				;;
			--current)
				show_current=1
				;;
			*)
				break
				;;
		esac
		shift
	done

	mode="${mode:-all}"

	local ColorRange='' ColorReset='' ColorCurrent='' ColorDefault=''

	if [ "$color" = always ]; then
		ColorDefault="$(git config --get-color "" "white")"
		ColorCurrent="$(git config --get-color "" "bold")"
		ColorRange="$(  git config --get-color "" "yellow")"
		ColorReset="$(  git config --get-color "" "reset")"
	fi

	case "$mode" in
		versions)
			if [ "$#" -gt 0 ]; then
				parse_patchset "$1"
				shift
			else
				current_patchset
			fi
			;;
		*)
			patchset[$P_NAME]='*'
			;;
	esac

	[ "$#" -eq 0 ] ||
		fatal "too many arguments"

	{
		git for-each-ref \
			--format='%(if)%(HEAD)%(then)*%(else)-%(end) %(objectname:short) %(refname:lstrip=3)' \
			"refs/heads/patchset/${patchset[$P_NAME]}/$ver[0-9]*" |
			sort -V -t\  -k3,3
		printf '\n'
	} |
	while read -r on_mark on_objectname on_branchname; do
		on_patchset="${on_branchname%/$ver*}"

		while [ -n "${branchname-}" ]; do
			case "$mode" in
				all|versions)
					;;
				latest)
					if [ -n "$show_current" ] && [ "$branchname" = "${patchset[$P_FULL]-}" ]; then
						:;
					elif [ "${prev_patchset:-$on_patchset}" = "$on_patchset" ]; then
						break
					fi
					;;
			esac

			basecommit="$(basecommit_for "patchset/$branchname")" ||
				break

			[ "$mark" = '*' ] &&
				current="$ColorCurrent" ||
				current=''

			printf '%1s %s..%s %7s %s%s\n' \
				"${current}${ColorDefault}${mark}" \
				"${ColorRange}${basecommit}" \
				"${objectname}${ColorDefault}" \
				"($(git rev-list --count "$basecommit..$objectname"))" \
				"${branchname}${ColorReset}"
			break
		done

		mark="$on_mark"
		objectname="$on_objectname"
		branchname="$on_branchname"
		prev_patchset="$on_patchset"
	done
}

help_version()
{
	case "$1" in
		usage) printf 'version [--major|--minor] [<patchset>] [number]\n'
			;;
		descr) builtin_cat <<-EOF
			Creates branch for a new version of <patchset>. Branch will
			copy the description and recipient list.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --major      increment major version number.
			  --minor      increment minor version number.
			  -h, --help   show this text and exit.
			EOF
			;;
	esac
}

cmd_version()
{
	local newname='' newver='' branchname='' inc=''

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help version
				return
				;;
			--minor)
				inc=minor
				;;
			--major)
				inc=major
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" -gt 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	if [ "$#" -gt 0 ]; then
		newver="${1#[av]}"
		shift
	fi

	[ "$#" -eq 0 ] ||
		fatal "too many arguments"

	if [ -z "$newver" ]; then
		newver="$(git for-each-ref --format='%(refname)' "refs/heads/patchset/${patchset[$P_NAME]}/" |
			sed -e 's/^.*\/[av]//' |
			sort --version-sort |
			tail -1)"
		newver="${newver:-1}"

		if [ -z "${newver##*.[0-9]*}" ]; then
			case "${inc:-minor}" in
				major) newver="$((${newver%%.*} + 1)).0" ;;
				minor) newver="${newver%.*}.$((${newver##*.} + 1))" ;;
			esac
		else
			case "${inc:-major}" in
				major) newver="$(($newver + 1))" ;;
				minor) newver="$(($newver + 1)).0" ;;
			esac
		fi
	fi

	newname="patchset/${patchset[$P_NAME]}/v$newver"

	! git rev-parse "$newname" >/dev/null 2>&1 ||
		fatal "$newname: branch already exists"

	git branch -c "${patchset[$P_FULL]}" "$newname" ||
		fatal "unable to copy '${patchset[$P_FULL]}' branch"

	git switch "$newname" ||
		fatal "unable to switch to '$newname'"

	message "created a new version of patchset: $newname"
}

help_cover()
{
	case "$1" in
		usage) printf 'cover [-e|--edit] [--no-pager] [<patchset>]\n'
			;;
		descr) builtin_cat <<-EOF
			Shows or changes the description of the patchset. This description
			will be used for cover-letter.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --no-pager   do not pipe git output into a pager.
			  -e, --edit   open editor to change the description.
			  -h, --help   show this text and exit.
			EOF
			;;
	esac
}

cmd_cover()
{
	local mode=list use_pager=1 pager=''
	local to cc args patchset

	to=(); cc=(); args=();

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help cover
				return
				;;
			-e|--edit)
				mode=edit
				;;
			--no-pager)
				use_pager=
				;;
			--)
				shift
				break
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}" "$@"

	if [ "$#" -gt 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	[ "$#" -eq 0 ] ||
		fatal "too many arguments"

	[ -n "${patchset[$P_NAME]}" ] && [ -n "${patchset[$P_VERS]}" ] ||
		fatal "unable to parse patchset"

	case "$mode" in
		edit)
			git branch --edit-description "${patchset[$P_FULL]}"
			;;
		list)
			if [ -n "$use_pager" ] && [ -t 1 ]; then
				get_pager pager
				describe_patchset "${patchset[$P_FULL]}" |$pager
			else
				describe_patchset "${patchset[$P_FULL]}"
			fi
			;;
	esac
}

help_log()
{
	case "$1" in
		usage) printf 'log [<patchset>] [options]\n'
			;;
		descr) builtin_cat <<-EOF
			Shortcut for git-log(1) to display patchset changes. The <options>
			will be passed to git-log(1). Without any options, the command will
			show changes in the current patchset.
			EOF
			;;
		options)
			;;
	esac
}

cmd_log()
{
	local basecommit patchset args
	args=()

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help log
				return
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}"

	if [ "$#" -gt 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	basecommit="$(basecommit_for "${patchset[$P_FULL]}")" ||
		return 1

	git log "$@" "$basecommit..${patchset[$P_FULL]}"
}

help_export()
{
	case "$1" in
		usage) printf 'export [--resend] [--rfc] [(-o|--output-directory) DIR] [<patchset>] [<options>]\n'
			;;
		descr) builtin_cat <<-EOF
			Prepares patches for e-mail submission. The <options> will be passed
			to git-format-patch(1).
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  --resend                      shortcut to add RESEND tag to the subject.
			  --rfc                         shortcut to add RFC tag to the subject.
			  -o, --output-directory DIR    use <DIR> to store the resulting files
			                                (default: patches/PATCHSET/)
			  -h, --help                    show this text and exit.
			EOF
			;;
	esac
}

cmd_export()
{
	local subject_prefix='' basecommit arr args patchset
	local resend='' rfc='' outdir=''

	args=()

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help export
				return
				;;
			--resend)
				resend=RESEND
				;;
			--rfc)
				rfc=RFC
				;;
			-o|--output-directory|--output-directory=*)
				case "$1" in
					-o|--output-directory)
						shift
						outdir="$1"
						;;
					--output-directory=*)
						outdir="${1#--output-directory=}"
						;;
				esac
				;;
			--)
				shift
				break
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}" "$@"

	if [ "$#" != 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	[ -n "${patchset[$P_NAME]}" ] && [ -n "${patchset[$P_VERS]}" ] ||
		fatal "unable to parse patchset"

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.to ||:;
		git config --get-all branch.${patchset[$P_FULL]}.to ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--to=$n"
	done

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.cc ||:;
		git config --get-all branch.${patchset[$P_FULL]}.cc ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--cc=$n"
	done

	arr=()
	readarray -t arr <<< $(
		echo $resend $rfc;
		git config --get branch.${patchset[$P_FULL]}.subject-prefix ||:;
		echo PATCH;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			subject_prefix="${subject_prefix:+$subject_prefix }$n"
	done

	set -- "$@" "--subject-prefix=$subject_prefix"

	basecommit="$(basecommit_for "${patchset[$P_FULL]}")" ||
		return 1

	if [ -z "${patchset[$P_VERS]##*[!0-9]*}" ]; then
		# git-format-patch: switch `v' expects a numerical value
		ver="${patchset[$P_VERS]%%[!0-9]*}"
	fi

	outdir="${outdir:-patches/${patchset[$P_NAME]}/}"

	[ -d "$outdir" ] ||
		mkdir -p -- "$outdir"

	git format-patch -v "$ver" --thread --minimal --cover-from-description=auto \
		-o "$outdir" \
		"$@" "$basecommit..${patchset[$P_FULL]}"
}

help_send()
{
	case "$1" in
		usage) printf 'send [[<options>] <files|directory>]\n'
			;;
		descr) builtin_cat <<-EOF
			Sends patches by e-mail. The <options> will be passed
			to git-send-email(1). Without any options, the command
			will export current patchset itself.
			EOF
			;;
		options)
			;;
	esac
}

cmd_send()
{
	local args auto_export=''

	args=()

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help send
				return
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}"

	[ "$#" -gt 0 ] ||
		auto_export=1

	git --list-cmds=main |
		while read -r n; do [ "$n" != 'send-email' ] || exit 1; done &&
		fatal "git-send-email(1) not found" ||:

	if [ -n "$auto_export" ]; then
		local dir branchname
		current_patchset branchname

		dir="$(git rev-parse --absolute-git-dir; false)/$PROGCMD-send" ||
			fatal "unable to find git directory"
		set -- "$dir"

		if ! mkdir -- "$1" >/dev/null 2>&1; then
			[ -d "$1" ] ||
				fatal "unable to create temporary directory: $1"
			fatal "another git-$PROGCMD-send(1) in progress"
		fi

		cmd_export "$branchname" -o "$1" >/dev/null
	fi

	local rc=0
	git send-email --to=' ' --confirm=always --format-patch --suppress-from \
		"$@" || rc=$?

	[ -z "$auto_export" ] ||
		rm -rf -- "$1" ||:

	return $rc
}

help_archive()
{
	case "$1" in
		usage) printf 'archive [--add|--restore] [<patchset>]\n'
			;;
		descr) builtin_cat <<-EOF
			Archive or unarchive the patchset. The specified version will be
			ignored. The archived patchset is not listed by default.
			EOF
			;;
		options) builtin_cat <<-EOF

			Options:
			  -a, --add       move all versions of patchset to archive.
			  -r, --restore   restore all versions of patchset.
			  -h, --help      show this text and exit.
			EOF
			;;
	esac
}

cmd_archive()
{
	local ver=l new='' args

	args=()

	while [ "$#" != 0 ]; do
		case "$1" in
			-h|--help)
				cmd_help archive
				return
				;;
			-a|--add)
				ver=v
				;;
			-r|--restore)
				ver=a
				;;
			--)
				shift
				break
				;;
			*)
				args+=("$1")
				;;
		esac
		shift
	done
	set -- "${args[@]}" "$@"

	case "$ver" in
		a) new=v ;;
		v) new=a ;;
		l)
			cmd_list --archive
			return
			;;
	esac

	if [ "$#" -gt 0 ]; then
		parse_patchset "$1"
		shift
	else
		current_patchset
	fi

	[ "$#" -eq 0 ] ||
		fatal "too many arguments"

	[ -z "${patchset[$P_VERS]}" ] ||
		message "WARNING: You have specified the version number but the entire patchset will be archived"

	git for-each-ref --format='%(refname:lstrip=2)' \
		"refs/heads/patchset/${patchset[$P_NAME]}/$ver[0-9]*" |
	while :; do
		read -r name ||:

		if [ -z "$name" ]; then
			[ -n "${found-}" ] ||
				message "patchset/${patchset[$P_NAME]}: patchset not found."
			break
		fi

		num="${name##*/[av]}"

		git branch -M "$name" "patchset/${patchset[$P_NAME]}/$new$num"

		message "patchset/${patchset[$P_NAME]}/$ver$num -> patchset/../$new$num"
		found=1
	done
}

help_help()
{
	case "$1" in
		usage) printf 'help [<command>]\n'
			;;
		descr) builtin_cat <<-EOF
			Shows this message and exit.
			EOF
			;;
		options)
			;;
	esac
}

commands=(`sed -n -e 's/^help_\([^[:space:]]\+\)().*/\1/p' "$0"`)
help_()
{
	local n s
	case "$1" in
		usage) printf '[<command>] [<args>]\n'
			for n in "${commands[@]}"; do
				"help_$n" usage
			done
			;;
		descr) builtin_cat <<-EOF
			This is highlevel utility for easy patchset creation. Each patchset has
			a version and description.
			EOF
			;;
		options) builtin_cat <<-EOF

			Commands:

			EOF
			for n in "${commands[@]}"; do
				"help_$n" descr |
				while read -r s; do
					printf "%-10s%s\n" "$n" "$s"
					n=
				done
				printf '\n'
			done
			;;
	esac
}

cmd_help()
{
	local n cmd='' found=''

	if [ "$#" -gt 0 ]; then
		cmd="$1"

		for n in "${commands[@]}"; do
			[ "$n" != "$cmd" ] || found=1
		done

		[ -n "$found" ] ||
			fatal "unknown command: $cmd"
	fi

	local prefix='Usage:'
	"help_$cmd" usage |
	while IFS='' read -r options; do
		printf '%s git %s %s\n' "$prefix" "$PROGCMD" "$options"
		prefix='   or:'
	done
	builtin_cat <<-EOF

	`
	"help_$cmd" descr
	"help_$cmd" options
	`

	Report bugs to authors.

	EOF
}

chdir_to_toplevel

[ "$#" != 0 ] || set -- list --latest --current
cmd="$1"; shift

trap exit_handler EXIT
trap signal_handler HUP PIPE INT QUIT TERM

case "$cmd" in
	-h|help)	cmd_help	"$@"	;;
	cr|create)	cmd_create	"$@"	;;
	ex|export)	cmd_export	"$@"	;;
	ls|list)	cmd_list	"$@"	;;
	vr|version)	cmd_version	"$@"	;;
	config|cover|log|send|archive)
			cmd_"$cmd"	"$@"	;;
	*)
		fatal "unknown command: $cmd"
		;;
esac


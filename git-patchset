#!/bin/bash -efu
# SPDX-License-Identifier: GPL-2.0

PROG="${0##*/}"
PROGCMD="${PROG#git-}"

[ -t 1 ] &&
	color=always ||
	color=none

message()
{
	printf >&2 '%s: %s\n' "$PROG" "$*"
}

fatal()
{
	message "$*"
	exit 1
}

valid_patchset()
{
	local __n="$2"
	__n="${__n#refs/}"
	__n="${__n#heads/}"

	[ -z "${__n##patchset/*}" ] ||
		fatal "branch is not a patchset: $2"

	eval "$1=\"\$__n\""
}

current_patchset()
{
	local __v
	__v="$(git branch --show-current --format='%(refname)')" ||
		fatal "unable to obtain current branch name"
	valid_patchset "$1" "$__v"
}

branch_exists()
{
	git rev-parse "$1" >/dev/null 2>&1 ||
		fatal "unknown branch: $1"
}

builtin_cat()
{
	local s eof=
	while [ -z "$eof" ]; do
		read -N 1 s || eof=1
		printf '%s' "$s"
	done
}

cmd_help()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[<command>]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows this message and exit."
			return ;;
		options)
			return ;;
	esac

	local n cmd= found=
	[ "$#" = 0 ] || cmd="$1"

	set -- create new list info export send archive help

	if [ -n "$cmd" ]; then
		for n in "$@"; do
			[ "$n" != "$cmd" ] || found=1
		done
		[ -n "$found" ] ||
			fatal "unknown command: $cmd"
		builtin_cat <<-EOF
		Usage: git $PROGCMD $cmd `__PATCHSET_HELP=usage "cmd_$cmd"`

		`
		__PATCHSET_HELP=descr   "cmd_$cmd"
		__PATCHSET_HELP=options "cmd_$cmd"
		`

		Report bugs to authors.

		EOF
		exit
	fi

	builtin_cat <<-EOF
	Usage: git $PROGCMD [<command>] [<args>]
	`for n in "$@"; do
		printf '   or: git %s %s ' "$PROGCMD" "$n"
		__PATCHSET_HELP=usage "cmd_$n"
	done`

	This is highlevel utility for easy patchset creation. Each patchset has
	a version and description.

	Commands:

	`for n in "$@"; do
		__PATCHSET_HELP=descr "cmd_$n" |
		while read -r s; do
			printf "%-10s%s\n" "$n" "$s"
			n=
		done
		printf '\n'
	done`

	Report bugs to authors.

	EOF
	exit
}

get_pager()
{
	local __get_pager
	__get_pager="$(git config --get patchset.pager)" ||
		__get_pager="$(git config --get core.pager)" ||
		__get_pager="less"
	eval "$1=\"\$__get_pager\""
}

show_field_list()
{
	local arr i n="$1"

	readarray -t arr <<< $(
		git config --get-all patchset.$2 ||:;
		git config --get-all branch.$branchname.$2 ||:;
	)

	for i in "${!arr[@]}"; do
		if [ -n "${arr[$i]}" ]; then
			printf "%-${#1}s %s" "$n" "${arr[$i]}"
			[ "$i" = "$(( ${#arr[@]} - 1 ))" ] ||
				printf ','
			printf '\n'
			n=
		fi
	done
}

basecommit_for()
{
	local merge
	if ! merge="$(git config "branch.$1.merge")"; then
		message "Use \`git branch -u <upstream> $1\` to set upstream for branch."
		fatal "not found upstream for branch: $1"
	fi
	git rev-parse --short "$merge"
}

cmd_list()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[--all|--latest] [--archive]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows a list of known patchsets. The current patchset will" \
			"be marked with an asterisk. The list also shows the base and" \
			"last commits as well as the number of commits."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  --all      show all versions of all patchsets." \
			"  --latest   show only latest versions of patchsets."
			"  --archive  show archived patchsets"
			return ;;
	esac

	local mode='' ver=v

	while [ "$#" != 0 ]; do
		case "$1" in
			--all)
				mode=all
				;;
			--latest)
				mode=latest
				;;
			--archive)
				mode="${mode:-latest}"
				ver=a
				;;
			*)
				break
				;;
		esac
		shift
	done

	mode="${mode:-all}"

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	local ColorRange='' ColorReset='' ColorCurrent='' ColorDefault=''

	if [ "$color" = always ]; then
		ColorDefault="$(git config --get-color "" "white")"
		ColorCurrent="$(git config --get-color "" "bold")"
		ColorRange="$(  git config --get-color "" "yellow")"
		ColorReset="$(  git config --get-color "" "reset")"
	fi

	{
		git for-each-ref \
			--format='%(if)%(HEAD)%(then)*%(else)-%(end) %(objectname:short) %(refname:lstrip=2)' \
			--sort=refname \
			"refs/heads/patchset/*/$ver[0-9]*"
		printf '\n'
	} |
	while read -r on_mark on_objectname on_branchname; do
		on_patchset="${on_branchname%/$ver*}"

		while [ -n "${branchname-}" ]; do
			[ "$mode" = 'all' ] ||
				[ "${prev_patchset:-$on_patchset}" != "$on_patchset" ] ||
				break

			basecommit="$(basecommit_for "$branchname")"

			[ "$mark" = '*' ] &&
				current="$ColorCurrent" ||
				current=''

			printf '%1s %s..%s %7s %s%s\n' \
				"${current}${ColorDefault}${mark}" \
				"${ColorRange}${basecommit}" \
				"${objectname}${ColorDefault}" \
				"($(git rev-list --count "$basecommit..$objectname"))" \
				"${branchname}${ColorReset}"
			break
		done

		mark="$on_mark"
		objectname="$on_objectname"
		branchname="$on_branchname"
		prev_patchset="$on_patchset"
	done
}

cmd_create()
{
	case "$__PATCHSET_HELP" in
		usage) printf '<newname> [<start-point>]\n'
			return ;;
		descr) printf '%s\n' \
			"Creates branch for a new patchset. The new branch will be" \
			"created with v1 version. The new branch head will point to" \
			"<start-point> commit or to current commit."
			return ;;
		options)
			return ;;
	esac

	[ "$#" != 0 ] ||
		fatal "patchset name required"

	local branchname='' startpoint=''

	branchname="$1"
	shift

	if [ "$#" != 0 ]; then
		startpoint="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	branchname="${branchname#/}"

	[ -n "$branchname" ] ||
		fatal "empty branch name is not allowed"

	git switch \
		--create "patchset/$branchname/v1" \
		--track ${startpoint:+"$startpoint"} ||
		fatal "unable to create new branch: patchset/$branchname/v1"

	git config \
		"branch.patchset/$branchname/v1.description" \
		"*** SUBJECT HERE ***

*** PATCHSET DESCRIPTION HERE ***

--
" ||
		fatal "unable to write empty description for patchset/$branchname/v1"

	git branch --edit-description "patchset/$branchname/v1" ||
		fatal "unable to change description"

	message "new patchset created: patchset/$branchname/v1"
}

cmd_new()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[<patchset>] [number]\n'
			return ;;
		descr) printf '%s\n' \
			"Creates branch for a new version of <patchset>. Branch will" \
			"copy the description and recipient list."
			return ;;
		options)
			return ;;
	esac

	local ver='' branchname='' name

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	if [ "$#" != 0 ]; then
		ver="$1"
		shift
		ver="${ver#v}"
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		current_patchset branchname

	valid_patchset branchname "$branchname"

	name="${branchname#patchset/}"
	name="${name%/[av]*}"

	if [ -z "$ver" ]; then
		ver="$(git for-each-ref --format='%(refname)' "refs/heads/patchset/$name/" |
			sed -e 's/^.*\/[av]//' |
			sort -n |
			tail -1)"
		ver=$(($ver + 1))
	fi

	git branch -c "$branchname" "patchset/$name/v$ver" ||
		fatal "unable to copy '$branchname' branch"

	git switch "patchset/$name/v$ver" ||
		fatal "unable to switch to 'patchset/$name/v$ver'"

	message "new patchset version created: patchset/$name/v$ver"
}

describe_patchset()
{
	local branchname basecommit subject_prefix

	branchname="$1"; shift
	basecommit="$(basecommit_for "$branchname")"

	subject_prefix="$(git config --get branch.$branchname.subject-prefix)" ||:
	subject_prefix="${subject_prefix:+$subject_prefix }PATCH"

	printf 'From %s %s\n' \
		"$(git config --get user.email)" \
		"$(LANG=C date -u)" ||:
	show_field_list To: to
	show_field_list Cc: cc
	printf 'Subject: [%s v%s 0/%s] %s\n\n' \
		"$subject_prefix" \
		"${branchname##*/[av]}" \
		"$(git rev-list --count "$basecommit..$branchname")" \
		"$(git config "branch.$branchname.description")"
	git rev-list --date-order --reverse --abbrev-commit --format=oneline \
		"$basecommit..$branchname"
}

cmd_info()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[-e|--edit] [--no-pager] [<patchset>]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows or changes the description of the patchset. This description" \
			"will be used for cover-letter."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  -e,--edit   open editor to change the description." \
			"  --no-pager  do not pipe git output into a pager."
			return ;;
	esac

	local branchname='' mode=list use_pager=1 pager=''

	while [ "$#" != 0 ]; do
		case "$1" in
			-e|--edit)
				mode=edit
				;;
			--no-pager)
				use_pager=
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		current_patchset branchname

	valid_patchset branchname "$branchname"
	branch_exists "$branchname"

	case "$mode" in
		edit)
			git branch --edit-description "$branchname"
			;;
		list)
			if [ -n "$use_pager" ] && [ -t 1 ]; then
				get_pager pager
				describe_patchset "$branchname" |$pager
			else
				describe_patchset "$branchname"
			fi
			;;
	esac
}

cmd_export()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[--resend] [--rfc] [<patchset>] [<options>]\n'
			return ;;
		descr) printf '%s\n' \
			"Prepares patches for e-mail submission. The <options> will be passed" \
			"to git-format-patch(1)."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  --resend  shortcut to add RESEND tag to the subject." \
			"  --rfc     shortcut to add RFC tag to the subject."
			return ;;
	esac

	local subject_prefix='' branchname='' basecommit ver arr
	local resend='' rfc=''

	while [ "$#" != 0 ]; do
		case "$1" in
			--resend)
				resend=RESEND
				;;
			--rfc)
				rfc=RFC
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		if [ -n "$1" ] && [ -z "${1##patchset/*}" ] && git rev-parse "$1" >/dev/null 2>&1; then
			branchname="$1"
			shift
		fi
	fi

	[ -n "$branchname" ] ||
		current_patchset branchname

	valid_patchset branchname "$branchname"
	branch_exists "$branchname"

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.to ||:;
		git config --get-all branch.$branchname.to ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--to=$n"
	done

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.cc ||:;
		git config --get-all branch.$branchname.cc ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--cc=$n"
	done

	arr=()
	readarray -t arr <<< $(
		echo $resend $rfc;
		git config --get branch.$branchname.subject-prefix ||:;
		echo PATCH;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			subject_prefix="${subject_prefix:+$subject_prefix }$n"
	done

	set -- "$@" "--subject-prefix=$subject_prefix"

	basecommit="$(basecommit_for "$branchname")"
	ver="${branchname##*/v}"

	git format-patch -v "$ver" --thread --minimal --cover-from-description=auto \
		"$@" "$basecommit..$branchname"
}

cmd_send()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[[<options>] <files|directory>]\n'
			return ;;
		descr) printf '%s\n' \
			"Sends patches by e-mail. The <options> will be passed" \
			"to git-send-email(1). Without any options, the command" \
			"will export current patchset itself."
			return ;;
		options)
			return ;;
	esac

	local auto_export=''

	[ "$#" != 0 ] ||
		auto_export=1

	git --list-cmds=main |
		while read -r n; do [ "$n" != 'send-email' ] || exit 1; done &&
		fatal "git-send-email(1) not found" ||:

	local dir branchname
	current_patchset branchname

	if [ -n "$auto_export" ]; then
		dir="$(git rev-parse --absolute-git-dir; false)/$PROGCMD-send" ||
			fatal "unable to find git directory"
		set -- "$dir"

		if ! mkdir -- "$1" >/dev/null 2>&1; then
			[ -d "$1" ] ||
				fatal "unable to create temporary directory: $1"
			fatal "another git-$PROGCMD-send(1) in progress"
		fi

		cmd_export "$branchname" -o "$1" >/dev/null
	fi

	local rc=0
	git send-email --to=' ' --confirm=always --format-patch --suppress-from \
		"$@" || rc=$?

	[ -z "$auto_export" ] ||
		rm -rf -- "$1" ||:

	return $rc
}

cmd_archive()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[--add|--restore] [<patchset>]\n'
			return ;;
		descr) printf '%s\n' \
			"Archive or unarchive the patchset. The specified version will be "\
			"ignored. The archived patchset is not listed by default."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  -a, --add       Move all versions of patchset to archive." \
			"  -r, --restore   Restore all versions of patchset."
			return ;;
	esac

	local ver=v new='' branchname=''

	while [ "$#" != 0 ]; do
		case "$1" in
			-a|--add)
				ver=v
				;;
			-r|--restore)
				ver=a
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	case "$ver" in
		a) new=v ;;
		v) new=a ;;
	esac

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		current_patchset branchname

	valid_patchset branchname "$branchname"

	[ -n "${branchname##*/[av]*}" ] ||
		branchname="${branchname%/[av]*}"

	git for-each-ref --format='%(refname:lstrip=2)' \
		"refs/heads/$branchname/$ver[0-9]*" |
	while read -r name; do
		num="${name##*/$ver}"
		newname="${name%/$ver*}/$new${name##*/$ver}"

		git branch -M "$name" "$newname"

		message "${name%/$ver*}/$ver$num -> patchset/../$new$num"
	done
}

[ "$#" != 0 ] || set -- list --latest
cmd="$1"; shift

__PATCHSET_HELP=

case "$cmd" in
	-h|help)   cmd_help "$@"      ;;
	cr|create) cmd_create "$@"    ;;
	ex|export) cmd_export "$@"    ;;
	ls|list)   cmd_list "$@"      ;;
	info|cover|cover-letter)
	           cmd_info "$@"      ;;
	new)       cmd_new "$@"       ;;
	send)      cmd_send "$@"      ;;
	archive)   cmd_archive "$@"   ;;
	*)
		fatal "unknown command: $cmd"
		;;
esac

#!/bin/bash -efu
# SPDX-License-Identifier: GPL-2.0

PROG="${0##*/}"
PROGCMD="${PROG#git-}"

[ -t 1 ] &&
	color=always ||
	color=none

message()
{
	printf >&2 '%s: %s\n' "$PROG" "$*"
}

fatal()
{
	message "$*"
	exit 1
}

valid_patchset()
{
	local __n="$2"
	__n="${__n#refs/}"
	__n="${__n#heads/}"

	[ -z "${__n##patchset/*}" ] ||
		fatal "Branch is not a patchset: $2"

	eval "$1=\"\$__n\""
}

help_line()
{
	local i n s
	i="$1"; shift
	n="$1"; shift
	for s in "$@"; do
		printf "%-${i}s%s\n" "$n" "$s"
		n=
	done
}

cmd_help()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD help"
			return ;;
		descr) help_line 10 help \
			"Shows this message and exit."
			return ;;
	esac

	set -- create new list info export send help

	cat <<-EOF
	Usage: git $PROGCMD [<command>] [<args>]
	`for n in "$@"; do __PATCHSET_HELP=usage "cmd_$n"; done`

	This is highlevel utility for easy patchset creation. Patchsets have
	a version and description.

	Commands:

	`for n in "$@"; do __PATCHSET_HELP=descr "cmd_$n"; done`

	Report bugs to authors.

	EOF
	exit
}

get_pager()
{
	local __get_pager
	__get_pager="$(git config --get patchset.pager)" ||
		__get_pager="$(git config --get core.pager)" ||
		__get_pager="less"
	eval "$1=\"\$__get_pager\""
}

show_field_list()
{
	local arr i n="$1"

	readarray -t arr <<< $(
		git config --get-all patchset.$2 ||:;
		git config --get-all branch.$branchname.$2 ||:;
	)

	for i in "${!arr[@]}"; do
		if [ -n "${arr[$i]}" ]; then
			printf "%-${#1}s %s" "$n" "${arr[$i]}"
			[ "$i" = "$(( ${#arr[@]} - 1 ))" ] ||
				printf ','
			printf '\n'
			n=
		fi
	done
}

basecommit_for()
{
	local merge
	if ! merge="$(git config "branch.$1.merge")"; then
		message "Use \`git branch -u <upstream> $1\` to set upstream for branch."
		fatal "not found upstream for branch: $1"
	fi
	git rev-parse --short "$merge"
}

cmd_list()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD list [--all|--latest]"
			return ;;
		descr) help_line 10 list \
			"Shows a list of known patchsets. The current patchset will" \
			"be marked with an asterisk. The list also shows the base and" \
			"last commits as well as the number of commits." \
			""
			return ;;
	esac

	local mode='all'

	while [ "$#" != 0 ]; do
		case "$1" in
			--all)
				mode=all
				;;
			--latest)
				mode=latest
				;;
			*)
				break
				;;
		esac
		shift
	done

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	local ColorRange='' ColorReset='' ColorCurrent='' ColorDefault=''

	if [ "$color" = always ]; then
		ColorDefault="$(git config --get-color "" "white")"
		ColorCurrent="$(git config --get-color "" "bold")"
		ColorRange="$(  git config --get-color "" "yellow")"
		ColorReset="$(  git config --get-color "" "reset")"
	fi

	{
		git for-each-ref \
			--format='%(if)%(HEAD)%(then)*%(else)-%(end) %(objectname:short) %(refname:lstrip=2)' \
			--sort=refname \
			'refs/heads/patchset/'
		printf '\n'
	} |
	while read -r on_mark on_objectname on_branchname; do
		on_patchset="${on_branchname%/v*}"

		while [ -n "${branchname-}" ]; do
			[ "$mode" = 'all' ] ||
				[ "${prev_patchset:-$on_patchset}" != "$on_patchset" ] ||
				break

			basecommit="$(basecommit_for "$branchname")"

			[ "$mark" = '*' ] &&
				current="$ColorCurrent" ||
				current=''

			printf '%1s %s..%s %7s %s%s\n' \
				"${current}${ColorDefault}${mark}" \
				"${ColorRange}${basecommit}" \
				"${objectname}${ColorDefault}" \
				"($(git rev-list --count "$basecommit..$objectname"))" \
				"${branchname}${ColorReset}"
			break
		done

		mark="$on_mark"
		objectname="$on_objectname"
		branchname="$on_branchname"
		prev_patchset="$on_patchset"
	done
}

cmd_create()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD create <newname> [<start-point>]"
			return ;;
		descr) help_line 10 create \
			"Creates branch for a new patchset. The new branch will be" \
			"created with v1 version. The new branch head will point to" \
			"<start-point> commit or to current commit." \
			""
			return ;;
	esac

	[ "$#" != 0 ] ||
		fatal "patchset name required"

	local branchname='' startpoint=''

	branchname="$1"
	shift

	if [ "$#" != 0 ]; then
		startpoint="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	branchname="${branchname#/}"

	[ -n "$branchname" ] ||
		fatal "empty branch name is not allowed"

	git switch \
		--create "patchset/$branchname/v1" \
		--track ${startpoint:+"$startpoint"} ||
		fatal "unable to create new branch: patchset/$branchname/v1"

	git config \
		"branch.patchset/$branchname/v1.description" \
		"*** SUBJECT HERE ***

*** PATCHSET DESCRIPTION HERE ***

--
" ||
		fatal "unable to write empty description for patchset/$branchname/v1"

	git branch --edit-description "patchset/$branchname/v1" ||
		fatal "unable to change description"

	message "new patchset created: patchset/$branchname/v1"
}

cmd_new()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD new [<patchset>] [number]"
			return ;;
		descr) help_line 10 new \
			"Creates branch for a new version of <patchset>. Branch will" \
			"copy the description and recipient list." \
			""
			return ;;
	esac

	local ver='' branchname='' name

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	if [ "$#" != 0 ]; then
		ver="$1"
		shift
		ver="${ver#v}"
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		branchname="$(git branch --show-current --format='%(refname)')"

	valid_patchset branchname "$branchname"

	name="${branchname#patchset/}"
	name="${name%/v*}"

	if [ -z "$ver" ]; then
		ver="$(git for-each-ref --format='%(refname:lstrip=4)' "refs/heads/patchset/$name/" |
			sed -e 's/^v//' |
			sort -n |
			tail -1)"
		ver=$(($ver + 1))
	fi

	git branch -c "$branchname" "patchset/$name/v$ver" ||
		fatal "unable to copy '$branchname' branch"

	git switch "patchset/$name/v$ver" ||
		fatal "unable to switch to 'patchset/$name/v$ver'"

	message "new patchset version created: patchset/$name/v$ver"
}

describe_patchset()
{
	local branchname basecommit subject_prefix

	branchname="$1"; shift
	basecommit="$(basecommit_for "$branchname")"

	subject_prefix="$(git config --get branch.$branchname.subject-prefix)" ||:
	subject_prefix="${subject_prefix:+$subject_prefix }PATCH"

	show_field_list To: to
	show_field_list Cc: cc
	printf 'Subject: [%s v%s 0/%s] %s\n\n' \
		"$subject_prefix" \
		"${branchname##*/v}" \
		"$(git rev-list --count "$basecommit..$branchname")" \
		"$(git config "branch.$branchname.description")"
	git rev-list --date-order --reverse --abbrev-commit --format=oneline \
		"$basecommit..$branchname"
}

cmd_info()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD info [-e|--edit] [--no-pager] [<patchset>]"
			return ;;
		descr) help_line 10 info \
			"Shows or changes the description of the patchset. This description" \
			"will be used for cover-letter." \
			""
			return ;;
	esac

	local branchname='' mode=list use_pager=1 pager=''

	while [ "$#" != 0 ]; do
		case "$1" in
			-e|--edit)
				mode=edit
				;;
			--no-pager)
				use_pager=
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		branchname="$(git branch --show-current --format='%(refname)')"

	valid_patchset branchname "$branchname"

	case "$mode" in
		edit)
			git branch --edit-description "$branchname"
			;;
		list)
			if [ -n "$use_pager" ] && [ -t 1 ]; then
				get_pager pager
				describe_patchset "$branchname" |$pager
			else
				describe_patchset "$branchname"
			fi
			;;
	esac
}

cmd_export()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD export [--resend] [--rfc] [<patchset>] [<options>]"
			return ;;
		descr) help_line 10 export \
			"Prepares patches for e-mail submission. The <options> will be passed" \
			"to git-format-patch(1)." \
			""
			return ;;
	esac

	local subject_prefix='' branchname='' basecommit ver arr
	local resend='' rfc=''

	while [ "$#" != 0 ]; do
		case "$1" in
			--resend)
				resend=RESEND
				;;
			--rfc)
				rfc=RFC
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		if [ -n "$1" ] && [ -z "${1##patchset/*}" ] && git rev-parse "$1" >/dev/null 2>&1; then
			branchname="$1"
			shift
		fi
	fi

	[ -n "$branchname" ] ||
		valid_patchset branchname "$(git branch --show-current --format='%(refname)')"

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.to ||:;
		git config --get-all branch.$branchname.to ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--to=$n"
	done

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.cc ||:;
		git config --get-all branch.$branchname.cc ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--cc=$n"
	done

	arr=()
	readarray -t arr <<< $(
		echo $resend $rfc;
		git config --get branch.$branchname.subject-prefix ||:;
		echo PATCH;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			subject_prefix="${subject_prefix:+$subject_prefix }$n"
	done

	set -- "$@" "--subject-prefix=$subject_prefix"

	basecommit="$(basecommit_for "$branchname")"
	ver="${branchname##*/v}"

	git format-patch -v "$ver" --thread --minimal --cover-from-description=auto \
		"$@" "$basecommit..$branchname"
}

cmd_send()
{
	case "$__PATCHSET_HELP" in
		usage) help_line 3 '' \
			"or: git $PROGCMD send [<options>] <files|directory>"
			return ;;
		descr) help_line 10 send \
			"Sends patches by e-mail. The <options> will be passed" \
			"to git-send-email(1)." \
			""
			return ;;
	esac

	git send-email --to=' ' --confirm=always --format-patch --suppress-from \
		"$@"
}

[ "$#" != 0 ] || set -- list --latest
cmd="$1"; shift

__PATCHSET_HELP=

case "$cmd" in
	-h|help)   cmd_help "$@"   ;;
	cr|create) cmd_create "$@" ;;
	ex|export) cmd_export "$@" ;;
	ls|list)   cmd_list "$@"   ;;
	info|cover|cover-letter)
	           cmd_info "$@"   ;;
	new)       cmd_new "$@"    ;;
	send)      cmd_send "$@"   ;;
	*)
		fatal "unknown command: $cmd"
		;;
esac

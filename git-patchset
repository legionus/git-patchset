#!/bin/bash -efu
# SPDX-License-Identifier: GPL-2.0

PROG="${0##*/}"
PROGCMD="${PROG#git-}"

[ -t 1 ] &&
	color=always ||
	color=none

message()
{
	printf >&2 '%s: %s\n' "$PROG" "$*"
}

fatal()
{
	message "$*"
	exit 1
}

valid_patchset()
{
	local __n="$2"
	__n="${__n#refs/}"
	__n="${__n#heads/}"

	[ -z "${__n##patchset/*}" ] ||
		fatal "Branch is not a patchset: $2"

	eval "$1=\"\$__n\""
}

cmd_help()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[<command>]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows this message and exit."
			return ;;
		options)
			return ;;
	esac

	local n cmd= found=
	[ "$#" = 0 ] || cmd="$1"

	set -- create new list info export send help

	if [ -n "$cmd" ]; then
		for n in "$@"; do
			[ "$n" != "$cmd" ] || found=1
		done
		[ -n "$found" ] ||
			fatal "unknown command: $cmd"
		cat <<-EOF
		Usage: git $PROGCMD $cmd `__PATCHSET_HELP=usage "cmd_$cmd"`

		`
		__PATCHSET_HELP=descr   "cmd_$cmd"
		__PATCHSET_HELP=options "cmd_$cmd"
		`

		Report bugs to authors.

		EOF
		exit
	fi

	cat <<-EOF
	Usage: git $PROGCMD [<command>] [<args>]
	`for n in "$@"; do
		printf '   or: git %s %s ' "$PROGCMD" "$n"
		__PATCHSET_HELP=usage "cmd_$n"
	done`

	This is highlevel utility for easy patchset creation. Each patchset has
	a version and description.

	Commands:

	`for n in "$@"; do
		__PATCHSET_HELP=descr "cmd_$n" |
		while read -r s; do
			printf "%-10s%s\n" "$n" "$s"
			n=
		done
		printf '\n'
	done`

	Report bugs to authors.

	EOF
	exit
}

get_pager()
{
	local __get_pager
	__get_pager="$(git config --get patchset.pager)" ||
		__get_pager="$(git config --get core.pager)" ||
		__get_pager="less"
	eval "$1=\"\$__get_pager\""
}

show_field_list()
{
	local arr i n="$1"

	readarray -t arr <<< $(
		git config --get-all patchset.$2 ||:;
		git config --get-all branch.$branchname.$2 ||:;
	)

	for i in "${!arr[@]}"; do
		if [ -n "${arr[$i]}" ]; then
			printf "%-${#1}s %s" "$n" "${arr[$i]}"
			[ "$i" = "$(( ${#arr[@]} - 1 ))" ] ||
				printf ','
			printf '\n'
			n=
		fi
	done
}

basecommit_for()
{
	local merge
	if ! merge="$(git config "branch.$1.merge")"; then
		message "Use \`git branch -u <upstream> $1\` to set upstream for branch."
		fatal "not found upstream for branch: $1"
	fi
	git rev-parse --short "$merge"
}

cmd_list()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[--all|--latest]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows a list of known patchsets. The current patchset will" \
			"be marked with an asterisk. The list also shows the base and" \
			"last commits as well as the number of commits."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  --all     show all versions of all patchsets." \
			"  --latest  show only latest versions of patchsets."
			return ;;
	esac

	local mode='all'

	while [ "$#" != 0 ]; do
		case "$1" in
			--all)
				mode=all
				;;
			--latest)
				mode=latest
				;;
			*)
				break
				;;
		esac
		shift
	done

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	local ColorRange='' ColorReset='' ColorCurrent='' ColorDefault=''

	if [ "$color" = always ]; then
		ColorDefault="$(git config --get-color "" "white")"
		ColorCurrent="$(git config --get-color "" "bold")"
		ColorRange="$(  git config --get-color "" "yellow")"
		ColorReset="$(  git config --get-color "" "reset")"
	fi

	{
		git for-each-ref \
			--format='%(if)%(HEAD)%(then)*%(else)-%(end) %(objectname:short) %(refname:lstrip=2)' \
			--sort=refname \
			'refs/heads/patchset/'
		printf '\n'
	} |
	while read -r on_mark on_objectname on_branchname; do
		on_patchset="${on_branchname%/v*}"

		while [ -n "${branchname-}" ]; do
			[ "$mode" = 'all' ] ||
				[ "${prev_patchset:-$on_patchset}" != "$on_patchset" ] ||
				break

			basecommit="$(basecommit_for "$branchname")"

			[ "$mark" = '*' ] &&
				current="$ColorCurrent" ||
				current=''

			printf '%1s %s..%s %7s %s%s\n' \
				"${current}${ColorDefault}${mark}" \
				"${ColorRange}${basecommit}" \
				"${objectname}${ColorDefault}" \
				"($(git rev-list --count "$basecommit..$objectname"))" \
				"${branchname}${ColorReset}"
			break
		done

		mark="$on_mark"
		objectname="$on_objectname"
		branchname="$on_branchname"
		prev_patchset="$on_patchset"
	done
}

cmd_create()
{
	case "$__PATCHSET_HELP" in
		usage) printf '<newname> [<start-point>]\n'
			return ;;
		descr) printf '%s\n' \
			"Creates branch for a new patchset. The new branch will be" \
			"created with v1 version. The new branch head will point to" \
			"<start-point> commit or to current commit."
			return ;;
		options)
			return ;;
	esac

	[ "$#" != 0 ] ||
		fatal "patchset name required"

	local branchname='' startpoint=''

	branchname="$1"
	shift

	if [ "$#" != 0 ]; then
		startpoint="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	branchname="${branchname#/}"

	[ -n "$branchname" ] ||
		fatal "empty branch name is not allowed"

	git switch \
		--create "patchset/$branchname/v1" \
		--track ${startpoint:+"$startpoint"} ||
		fatal "unable to create new branch: patchset/$branchname/v1"

	git config \
		"branch.patchset/$branchname/v1.description" \
		"*** SUBJECT HERE ***

*** PATCHSET DESCRIPTION HERE ***

--
" ||
		fatal "unable to write empty description for patchset/$branchname/v1"

	git branch --edit-description "patchset/$branchname/v1" ||
		fatal "unable to change description"

	message "new patchset created: patchset/$branchname/v1"
}

cmd_new()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[<patchset>] [number]\n'
			return ;;
		descr) printf '%s\n' \
			"Creates branch for a new version of <patchset>. Branch will" \
			"copy the description and recipient list."
			return ;;
		options)
			return ;;
	esac

	local ver='' branchname='' name

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	if [ "$#" != 0 ]; then
		ver="$1"
		shift
		ver="${ver#v}"
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		branchname="$(git branch --show-current --format='%(refname)')"

	valid_patchset branchname "$branchname"

	name="${branchname#patchset/}"
	name="${name%/v*}"

	if [ -z "$ver" ]; then
		ver="$(git for-each-ref --format='%(refname:lstrip=4)' "refs/heads/patchset/$name/" |
			sed -e 's/^v//' |
			sort -n |
			tail -1)"
		ver=$(($ver + 1))
	fi

	git branch -c "$branchname" "patchset/$name/v$ver" ||
		fatal "unable to copy '$branchname' branch"

	git switch "patchset/$name/v$ver" ||
		fatal "unable to switch to 'patchset/$name/v$ver'"

	message "new patchset version created: patchset/$name/v$ver"
}

describe_patchset()
{
	local branchname basecommit subject_prefix

	branchname="$1"; shift
	basecommit="$(basecommit_for "$branchname")"

	subject_prefix="$(git config --get branch.$branchname.subject-prefix)" ||:
	subject_prefix="${subject_prefix:+$subject_prefix }PATCH"

	show_field_list To: to
	show_field_list Cc: cc
	printf 'Subject: [%s v%s 0/%s] %s\n\n' \
		"$subject_prefix" \
		"${branchname##*/v}" \
		"$(git rev-list --count "$basecommit..$branchname")" \
		"$(git config "branch.$branchname.description")"
	git rev-list --date-order --reverse --abbrev-commit --format=oneline \
		"$basecommit..$branchname"
}

cmd_info()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[-e|--edit] [--no-pager] [<patchset>]\n'
			return ;;
		descr) printf '%s\n' \
			"Shows or changes the description of the patchset. This description" \
			"will be used for cover-letter."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  -e,--edit   open editor to change the description." \
			"  --no-pager  do not pipe git output into a pager."
			return ;;
	esac

	local branchname='' mode=list use_pager=1 pager=''

	while [ "$#" != 0 ]; do
		case "$1" in
			-e|--edit)
				mode=edit
				;;
			--no-pager)
				use_pager=
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		branchname="$1"
		shift
	fi

	[ "$#" = 0 ] ||
		fatal "too many arguments"

	[ -n "$branchname" ] ||
		branchname="$(git branch --show-current --format='%(refname)')"

	valid_patchset branchname "$branchname"

	case "$mode" in
		edit)
			git branch --edit-description "$branchname"
			;;
		list)
			if [ -n "$use_pager" ] && [ -t 1 ]; then
				get_pager pager
				describe_patchset "$branchname" |$pager
			else
				describe_patchset "$branchname"
			fi
			;;
	esac
}

cmd_export()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[--resend] [--rfc] [<patchset>] [<options>]\n'
			return ;;
		descr) printf '%s\n' \
			"Prepares patches for e-mail submission. The <options> will be passed" \
			"to git-format-patch(1)."
			return ;;
		options) printf '%s\n' \
			"" \
			"Options:" \
			"  --resend  shortcut to add RESEND tag to the subject." \
			"  --rfc     shortcut to add RFC tag to the subject."
			return ;;
	esac

	local subject_prefix='' branchname='' basecommit ver arr
	local resend='' rfc=''

	while [ "$#" != 0 ]; do
		case "$1" in
			--resend)
				resend=RESEND
				;;
			--rfc)
				rfc=RFC
				;;
			--)
				shift
				break
				;;
			*)
				break
				;;
		esac
		shift
	done

	if [ "$#" != 0 ]; then
		if [ -n "$1" ] && [ -z "${1##patchset/*}" ] && git rev-parse "$1" >/dev/null 2>&1; then
			branchname="$1"
			shift
		fi
	fi

	[ -n "$branchname" ] ||
		valid_patchset branchname "$(git branch --show-current --format='%(refname)')"

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.to ||:;
		git config --get-all branch.$branchname.to ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--to=$n"
	done

	arr=()
	readarray -t arr <<< $(
		git config --get-all patchset.cc ||:;
		git config --get-all branch.$branchname.cc ||:;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			set -- "$@" "--cc=$n"
	done

	arr=()
	readarray -t arr <<< $(
		echo $resend $rfc;
		git config --get branch.$branchname.subject-prefix ||:;
		echo PATCH;
	)
	for n in "${arr[@]}"; do
		[ -z "$n" ] ||
			subject_prefix="${subject_prefix:+$subject_prefix }$n"
	done

	set -- "$@" "--subject-prefix=$subject_prefix"

	basecommit="$(basecommit_for "$branchname")"
	ver="${branchname##*/v}"

	git format-patch -v "$ver" --thread --minimal --cover-from-description=auto \
		"$@" "$basecommit..$branchname"
}

cmd_send()
{
	case "$__PATCHSET_HELP" in
		usage) printf '[[<options>] <files|directory>]\n'
			return ;;
		descr) printf '%s\n' \
			"Sends patches by e-mail. The <options> will be passed" \
			"to git-send-email(1). Without any options, the command" \
			"will export current patchset itself."
			return ;;
		options)
			return ;;
	esac

	local auto_export=''

	[ "$#" != 0 ] ||
		auto_export=1

	git --list-cmds=main | grep -qs send-email ||
		fatal "git-send-email(1) not found"

	if [ -n "$auto_export" ]; then
		local gitdir

		gitdir="$(git rev-parse --absolute-git-dir)" ||
			fatal "unable to find git directory"

		if ! mkdir -- "$gitdir/patchset" 2>/dev/null; then
			[ ! -d "$gitdir/patchset" ] ||
				fatal "another git-patchset-send(1) in progress"
			fatal "unable to create temporary directory: $gitdir/patchset"
		fi

		set -- `cmd_export -o "$gitdir/patchset"`
	fi

	local rc=0
	git send-email --to=' ' --confirm=always --format-patch --suppress-from \
		"$@" || rc=$?

	[ -z "$auto_export" ] ||
		rm -rf -- "$gitdir/patchset" ||:

	return $rc
}

[ "$#" != 0 ] || set -- list --latest
cmd="$1"; shift

__PATCHSET_HELP=

case "$cmd" in
	-h|help)   cmd_help "$@"   ;;
	cr|create) cmd_create "$@" ;;
	ex|export) cmd_export "$@" ;;
	ls|list)   cmd_list "$@"   ;;
	info|cover|cover-letter)
	           cmd_info "$@"   ;;
	new)       cmd_new "$@"    ;;
	send)      cmd_send "$@"   ;;
	*)
		fatal "unknown command: $cmd"
		;;
esac
